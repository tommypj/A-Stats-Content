"""Fix knowledge_sources.project_id to UUID type

DB-C1: Migration 032 added knowledge_sources.project_id as VARCHAR(36) to
reference projects.id, but projects.id is a UUID column. This corrective
migration converts the column type to UUID using a USING cast, which is
safe because all existing values are already UUID strings.

Revision ID: 036
Revises: 035
Create Date: 2026-03-02
"""
from alembic import op

revision = "036"
down_revision = "035"
branch_labels = None
depends_on = None


def upgrade() -> None:
    # Idempotent: only convert if column exists and is still VARCHAR.
    # Drop the plain index first (it will be recreated with correct type).
    op.execute("""
        DO $$
        BEGIN
            -- Drop the existing non-partial index if it exists; it references
            -- the VARCHAR column and would block the type change.
            IF EXISTS (
                SELECT 1 FROM pg_indexes
                WHERE tablename = 'knowledge_sources'
                  AND indexname = 'ix_knowledge_sources_project_id'
            ) THEN
                DROP INDEX ix_knowledge_sources_project_id;
            END IF;

            -- Convert VARCHAR(36) â†’ UUID if needed.
            IF EXISTS (
                SELECT 1 FROM information_schema.columns
                WHERE table_name = 'knowledge_sources'
                  AND column_name = 'project_id'
                  AND data_type = 'character varying'
            ) THEN
                -- Remove the FK constraint first so we can alter the type.
                -- The constraint name is generated by PostgreSQL; look it up
                -- dynamically so this is safe even if it was never created.
                DECLARE
                    v_constraint TEXT;
                BEGIN
                    SELECT conname INTO v_constraint
                    FROM pg_constraint c
                    JOIN pg_class t ON t.oid = c.conrelid
                    WHERE t.relname = 'knowledge_sources'
                      AND c.contype = 'f'
                      AND pg_get_constraintdef(c.oid) LIKE '%project_id%';

                    IF v_constraint IS NOT NULL THEN
                        EXECUTE 'ALTER TABLE knowledge_sources DROP CONSTRAINT ' || quote_ident(v_constraint);
                    END IF;
                END;

                ALTER TABLE knowledge_sources
                    ALTER COLUMN project_id TYPE UUID USING project_id::UUID;

                -- Restore the FK constraint now that the column is UUID.
                ALTER TABLE knowledge_sources
                    ADD CONSTRAINT knowledge_sources_project_id_fkey
                    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE;
            END IF;

            -- Recreate the plain index with the correct column type.
            IF NOT EXISTS (
                SELECT 1 FROM pg_indexes
                WHERE tablename = 'knowledge_sources'
                  AND indexname = 'ix_knowledge_sources_project_id'
            ) THEN
                CREATE INDEX ix_knowledge_sources_project_id
                    ON knowledge_sources (project_id);
            END IF;
        END $$;
    """)


def downgrade() -> None:
    op.execute("""
        DO $$
        BEGIN
            IF EXISTS (
                SELECT 1 FROM information_schema.columns
                WHERE table_name = 'knowledge_sources'
                  AND column_name = 'project_id'
                  AND data_type = 'uuid'
            ) THEN
                DECLARE
                    v_constraint TEXT;
                BEGIN
                    SELECT conname INTO v_constraint
                    FROM pg_constraint c
                    JOIN pg_class t ON t.oid = c.conrelid
                    WHERE t.relname = 'knowledge_sources'
                      AND c.contype = 'f'
                      AND pg_get_constraintdef(c.oid) LIKE '%project_id%';

                    IF v_constraint IS NOT NULL THEN
                        EXECUTE 'ALTER TABLE knowledge_sources DROP CONSTRAINT ' || quote_ident(v_constraint);
                    END IF;
                END;

                ALTER TABLE knowledge_sources
                    ALTER COLUMN project_id TYPE VARCHAR(36) USING project_id::VARCHAR;

                ALTER TABLE knowledge_sources
                    ADD CONSTRAINT knowledge_sources_project_id_fkey
                    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE;
            END IF;
        END $$;
    """)
